package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"fmt"
	"log"
	"os"
	"test_executor/graph/model"
	f "test_executor/service"

	// f"test_executor/functions"

	"github.com/docker/docker/client"
)

// StartTest is the resolver for the startTest field.
func (r *mutationResolver) StartTest(ctx context.Context, input model.StartTestInput) (*model.Test, error) {
	return f.StartTest(ctx, input)
}

// UpdateTest is the resolver for the updateTest field.
func (r *mutationResolver) UpdateTest(ctx context.Context, input model.UpdateTestInput) (*model.Test, error) {
	return f.UpdateTestByID(ctx, input)
}

// SeleniumPull is the resolver for the seleniumPull field.
func (r *mutationResolver) SeleniumPull(ctx context.Context) (string, error) {

	fmt.Println("-------Pulling selenium image from docker hub registory-------")

	client, err := client.NewEnvClient()
	if err != nil {
		log.Fatalf("UNABLE to create docker client: %s", err)
	}

	image := "selenium/standalone-chrome"
	err = f.PullImageSelenium(client, image)

	if err != nil {
		log.Println(err)
		return "FAILED to Pull Selenium", nil
	}
	return "Selenium Pulled SUCCESSFULLY", nil
}

func (r *mutationResolver) SeleniumStart(ctx context.Context, input model.SeleniumInput) (string, error) {
	fmt.Println("-------Running Selenium_Container-------")
	client, err := client.NewEnvClient()
	containername := input.ContainerName
	portopening := "4444"
	inputEnv1 := []string{fmt.Sprintf("LISTENINGPORT=%s", portopening)}
	image := "selenium/standalone-chrome"

	err = f.RunContainerSelenium(client, image, containername, portopening, inputEnv1)
	if err != nil {
		log.Println(err)
		return err.Error(), nil
	}
	return "Selenium Started SUCCESSFULLY", nil

	// time.Sleep(10 * time.Second)

}

func (r *mutationResolver) SeleniumStop(ctx context.Context, input model.SeleniumInput) (string, error) {
	fmt.Println("-------Stop Selenium_Container-------")
	client, err := client.NewEnvClient()
	err = f.StopsSeleniumContainer(client, input.ContainerName)
	if err != nil {
		log.Println(err)
		return "Selenium FAILED to Stop", nil
	}
	log.Println(err)
	return "Selenium Stopped SUCCESSFULLY", nil
}

// SeleniumStart is the resolver for the seleniumStart field.
func (r *mutationResolver) SeleniumRemove(ctx context.Context, input model.SeleniumInput) (string, error) {
	fmt.Println("-------(Removing Selenium Container)-------")

	client, err := client.NewEnvClient()
	err = f.RemoveSeleniumContainer(client, input.ContainerName)

	if err != nil {
		log.Println(err)
		return "UNABLE to remove Selenium ", nil
	}
	return "Selenium Removed SUCCESSFULLY", nil
}


// ProjectBuildImage is the resolver for the projectBuildImage field.
func (r *mutationResolver) ProjectBuildImage(ctx context.Context, input model.ProjectBuildImageInput) (string, error) {
	fmt.Println("-------Create Project Image from a Docker File-------")
	client, err := client.NewEnvClient()
	if err != nil {
		log.Fatalf("UNABLE to create docker client: %s", err)
		return "FAILED to create Docker Client",err
	}

	tags1 := []string{input.ImgName}
	dockerfile1 := "Dockerfile"
	// contextPath1 := "C:\\Users\\abdul\\Desktop\\T-Hex\\t-hex\\app\\backend\\PythonTest"
	contextPath1 := input.ProjectPath //"example\\PythonTest"
	err = f.BuildImageforDockerFile2(client, tags1, dockerfile1, contextPath1)
	if err != nil {
		log.Println(err)
		os.Exit(1)
		return "FAILED to Build Project Image",nil
	}
	return "Project Image Built SUCCESSFULLY",nil
}

// ProjectContainerStart is the resolver for the projectContainerStart field.
func (r *mutationResolver) ProjectContainerStart(ctx context.Context, input model.ProjectContainerStartInput) (string, error) {
	fmt.Println("5) -------Running Project Contianer-------")
	client, err := client.NewEnvClient()
	if err != nil {
		log.Fatalf("UNABLE to create docker client: %s", err)
		return "FAILED to create Docker Client",err
	}

	containernameproject_test1 := input.ContainerName
	portopening2 := "8081"
	image2 := input.ImageName
	// scname := "Selenium_Container"
	inputEnv2 := []string{fmt.Sprintf("LISTENINGPORT=%s", portopening2)}
	err = f.RunContainerForProjectTestImage(client, image2, containernameproject_test1, portopening2, inputEnv2)
	if err != nil {
		log.Println(err)
	}
	return "Project Container Started Successfully",nil
}

// ProjectContainerStop is the resolver for the projectContainerStop field.
func (r *mutationResolver) ProjectContainerStop(ctx context.Context, input model.ProjectContainerEndInput) (string, error) {
	fmt.Println("-------Stopping Project Container-------")
	client, err := client.NewEnvClient()
	if err != nil {
		log.Fatalf("UNABLE to create docker client: %s", err)
		return "FAILED to create Docker Client",err
	}

	err = f.StopProjectContainer(client, input.ContainerName)
	if err != nil {
		log.Println(err)
		return "Project Container FAILED to Stop", nil
	}
	return "Project Container Stopped SUCCESSFULLY",nil
}

// ProjectContainerRemove is the resolver for the projectContainerRemove field.
func (r *mutationResolver) ProjectContainerRemove(ctx context.Context, input model.ProjectContainerEndInput) (string, error) {
	fmt.Println("-------Removing Project Container-------")
	client, err := client.NewEnvClient()
	if err != nil {
		log.Fatalf("UNABLE to create docker client: %s", err)
		return "FAILED to create Docker Client",err
	}

	err = f.RemoveProjectContainer(client, input.ContainerName)
	if err != nil {
		log.Println(err)
		//"Project Container FAILED to be Removed"
		return err.Error(), nil
	}
	return "Project Container Removed SUCCESSFULLY",nil
}

// Tests is the resolver for the tests field.
func (r *queryResolver) Tests(ctx context.Context) ([]*model.Test, error) {
	return f.GetAllTest(ctx)
}

// Test is the resolver for the test field.
func (r *queryResolver) Test(ctx context.Context, id int) (*model.Test, error) {
	return f.GetTestByID(ctx,id)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
